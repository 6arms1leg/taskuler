/** \file */

#ifndef TKLSDLR_H
#define TKLSDLR_H

/* `"` used intentionally.  This allows the user to override and provide his
 * own type definitions before falling back to libc.
 */
#include "stdint.h"
#include "stddef.h"
#include "stdbool.h"

#include "TKLtyp.h"
#include "TKLsdlrCfg.h"

/** \brief Rel. sys. time tick query function signature */
typedef uint32_t (* TKLtyp_p_getTick_t)(void);

/* OPERATIONS
 * ==========
 */

/**
 * \brief Registers the relative system time tick with the scheduler
 *
 * \param p_getTick Pointer to an access function that provides the current
 * relative system time tick count.
 * That time tick count access function has to be implemented by the user.
 * Typically, the time tick is generated by an ISR that periodically increments
 * a time tick count variable.  Since this time tick count variable is a shared
 * resource, it must be ensured that either:
 * * the access of this variable is atomic, or
 * * this access function is implemented with a critical region pattern inside.
 */
void TKLsdlr_setTickSrc(const TKLtyp_p_getTick_t p_getTick);

/**
 * \brief Registers a task list with the scheduler
 *
 * \param p_tskLst Task list
 * \param tskCnt Number of tasks within the provided task list
 */
void TKLsdlr_setTskLst(TKLtyp_tsk_t* const p_tskLst, const uint8_t tskCnt);

/**
 * \brief Get task list that is registered with the scheduler
 *
 * \return Task list that is registered with the scheduler
 *
 * \see TKLsdlr_setTaskAttributes()
 */
TKLtyp_tsk_t* TKLsdlr_getTskLst(void);

/**
 * \brief Get number of tasks within the task list that is registered with the
 * scheduler
 *
 * \return Number of tasks within task the list that is registered with the
 * scheduler
 *
 * \see TKLsdlr_setTaskAttributes()
 */
uint8_t TKLsdlr_cntTsk(void);

/**
 * \brief Get number of task deadline overruns
 *
 * \return Number of task deadline overruns
 */
uint8_t TKLsdlr_cntTskOverrun(void);

/** \brief Reset Task deadline overrun counter */
void TKLsdlr_clrTskOverrun(void);

/**
 * \brief Activate/deactivate a task within the task list that is registered
 * with the scheduler
 *
 * \param p_tskRunner Task runner that orchestrates module(s) interaction
 * sequence to achieve task goal
 * \param b_active Desired task activation status
 * \param b_updateLastRun Directive to update the time stamp of last task run
 * to the current relative system time tick count.
 * This is useful to start a timer (i.e., a one-shot task that deactives itself
 * at the end of its execution).
 */
void TKLsdlr_setTskAct(const TKLtyp_p_tskRunner_t p_tskRunner,
                       const bool active,
                       const bool updLastRun);

/**
 * \brief Scheduling algorithm execution cycle
 *
 * This function needs to be called from within the main `while(true)` endless
 * loop.
 */
void TKLsdlr_exec(void);

#endif /* TKLSDLR_H */
