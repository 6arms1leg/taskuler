/** \file */

#ifndef TKLSDLR_H
#define TKLSDLR_H

/* `"` used intentionally.  This allows the user to override and provide his
   own type definitions before falling back to libc. */
#include "stdint.h"
#include "stddef.h"
#include "stdbool.h"

#include "TKLtyp.h"
#include "TKLsdlrCfg.h"

/** \brief Relative system time tick query function signature */
typedef uint32_t (* TKLtyp_p_getTick_t)(void);

/* OPERATIONS
 * ==========
 */

/**
 * \brief Register relative system time tick with scheduler
 *
 * \param p_getTick Pointer to an access function that provides the current
 * relative system time tick count.
 * That time tick count access function has to be implemented by the user.
 * Typically, the time tick is generated by an ISR that periodically increments
 * a time tick count variable.  Since this time tick count variable is a shared
 * resource, it must be ensured that either:
 * * the access of this variable is atomic, or
 * * this access function is implemented with a critical region pattern inside.
 */
void TKLsdlr_setTickSrc(const TKLtyp_p_getTick_t p_getTick);

/**
 * \brief Register a task list with scheduler
 *
 * \param p_tskLst Task list
 * \param tskCnt Number of tasks within provided task list
 */
void TKLsdlr_setTskLst(TKLtyp_tsk_t* const p_tskLst, const uint8_t tskCnt);

/**
 * \brief Get task list that is registered with scheduler
 *
 * \return Task list that is registered with the scheduler
 *
 * \see TKLsdlr_setTaskAttributes()
 */
TKLtyp_tsk_t* TKLsdlr_getTskLst(void);

/**
 * \brief Get number of tasks within task list that is registered with
 * scheduler
 *
 * \return Number of tasks within task list that is registered with scheduler
 *
 * \see TKLsdlr_setTaskAttributes()
 */
uint8_t TKLsdlr_cntTsk(void);

/**
 * \brief Get number of task deadline overruns
 *
 * \return Number of task deadline overruns
 */
uint8_t TKLsdlr_cntTskOverrun(void);

/** \brief Reset Task deadline overrun counter */
void TKLsdlr_clrTskOverrun(void);

/**
 * \brief Activate/deactivate a task within task list that is registered with
 * scheduler
 *
 * \param p_tskRunner Task runner that orchestrates module(s) interaction
 * sequence to achieve task goal
 * \param b_active Desired task activation status
 * \param b_updateLastRun Directive to update time stamp of last task run to
 * current relative system time tick count.
 * This is useful to start a timer (i.e., one-shot task that deactives itself
 * at end of its execution).
 */
void TKLsdlr_setTskAct(const TKLtyp_p_tskRunner_t p_tskRunner,
                       const bool active,
                       const bool updLastRun);

/**
 * \brief Scheduling algorithm execution cycle
 *
 * This function needs to be called from within main endless "super loop".
 */
void TKLsdlr_exec(void);

#endif /* TKLSDLR_H */
